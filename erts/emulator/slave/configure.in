dnl Process this file with autoconf to produce a configure script. -*-m4-*-

dnl %CopyrightBegin%
dnl
dnl Copyright Ericsson AB 1997-2015. All Rights Reserved.
dnl
dnl The contents of this file are subject to the Erlang Public License,
dnl Version 1.1, (the "License"); you may not use this file except in
dnl compliance with the License. You should have received a copy of the
dnl Erlang Public License along with this software. If not, it can be
dnl retrieved online at http://www.erlang.org/.
dnl
dnl Software distributed under the License is distributed on an "AS IS"
dnl basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
dnl the License for the specific language governing rights and limitations
dnl under the License.
dnl
dnl %CopyrightEnd%

AC_INIT(sys/erl_epiphany_sys.h)
AC_PREREQ(2.59)

LM_PRECIOUS_VARS

if test "x$no_recursion" != "xyes" -a "x$OVERRIDE_CONFIG_CACHE" = "x"; then
    # We do not want to use a common cache!
    cache_file=/dev/null
fi

## Now, make sure that ERL_TOP is set and is the same as srcdir
##
if test -z "$ERL_TOP" || test ! -d $ERL_TOP ; then
  AC_MSG_ERROR(You need to set the environment variable ERL_TOP!)
fi
if test ! "${ERL_TOP}/erts/emulator/slave" -ef "$srcdir"; then
  AC_MSG_ERROR([You need to run configure with argument --srcdir=${ERL_TOP}/erts/emulator/slave])
fi
erl_top=${ERL_TOP}

# echo XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# echo X
# echo "X srcdir  = $srcdir"
# echo "X ERL_TOP = $ERL_TOP"
# echo X
# echo XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

AC_CONFIG_AUX_DIRS($srcdir/../../autoconf)

dnl ----------------------------------------------------------------------
dnl Figure out what system we are running on.
dnl ----------------------------------------------------------------------

if test "$cross_compiling" != "no"; then
    CROSS_COMPILING=yes
else
    dnl It would be nice to be able to change the default value of --host...
    AC_MSG_ERROR(You need to run configure with argument --host=epiphany-elf)
fi
AC_SUBST(CROSS_COMPILING)

AC_CONFIG_HEADER(include/config.h:config.h.in include/erl_int_sizes_config.h:../../include/erl_int_sizes_config.h.in)

dnl ----------------------------------------------------------------------
dnl Optional features.
dnl ----------------------------------------------------------------------
ENABLE_ALLOC_TYPE_VARS=
AC_SUBST(ENABLE_ALLOC_TYPE_VARS)

AC_ARG_ENABLE(threads,
AS_HELP_STRING([--enable-threads], [enable async thread support])
AS_HELP_STRING([--disable-threads], [disable async thread support]),
[ case "$enableval" in
    no) enable_threads=no ;;
    *)  enable_threads=yes ;;
  esac ], enable_threads=unknown)

AC_ARG_ENABLE(smp-support,
AS_HELP_STRING([--enable-smp-support], [enable smp support])
AS_HELP_STRING([--disable-smp-support], [disable smp support]),
[ case "$enableval" in
    no) enable_smp_support=no ;;
    *)  enable_smp_support=yes ;;
  esac ], enable_smp_support=unknown)

AC_ARG_ENABLE(lock-checking,
AS_HELP_STRING([--enable-lock-checking], [enable lock checking]),
[ case "$enableval" in
    no) enable_lock_check=no ;;
    *)  enable_lock_check=yes ;;
  esac
],
  enable_lock_check=no)

AC_ARG_ENABLE(lock-counter,
AS_HELP_STRING([--enable-lock-counter], [enable lock counters]),
[ case "$enableval" in
    no) enable_lock_count=no ;;
    *)  enable_lock_count=yes ;;
  esac ], enable_lock_count=no)

AC_ARG_ENABLE(fp-exceptions,
AS_HELP_STRING([--enable-fp-exceptions],
               [use hardware floating point exceptions (default if hipe enabled)]),
[ case "$enableval" in
    no) enable_fp_exceptions=no ;;
    *)  enable_fp_exceptions=yes ;;
  esac
],enable_fp_exceptions=auto)

AC_ARG_ENABLE(vm-probes,
AS_HELP_STRING([--enable-vm-probes],
               [add dynamic trace probes to the Beam VM (only possible if --with-dynamic-trace is enabled, and then default)]),
	       [ case "$enableval" in
    	       	 no) use_vm_probes=no ;;
    		 *)
			if  test X"$DYNAMIC_TRACE_FRAMEWORK" != X""; then
		 	    use_vm_probes=yes ;
			else
			    AC_MSG_ERROR(Can not enable VM probes without any dynamic tracing framework!);
			fi;;  
  		 esac ], if  test X"$DYNAMIC_TRACE_FRAMEWORK" != X""; then
		 	    use_vm_probes=yes ;
			else
			    use_vm_probes=no
			fi)

AC_SUBST(USE_VM_PROBES)
if test X"$use_vm_probes" = X"yes"; then
   USE_VM_PROBES=yes
   AC_DEFINE(USE_VM_PROBES,[1],
	     [Define to enable VM dynamic trace probes])
fi

AC_ARG_WITH(assumed-cache-line-size,
AS_HELP_STRING([--with-assumed-cache-line-size=SIZE],
               [specify assumed cache line size in bytes (valid values are powers of two between and including 1 and 8192; default is 8)]))

dnl Require the assumed cache-line size to be a power of two between 1 and 8192
case "$with_assumed_cache_line_size" in
     ""|no|yes)
	with_assumed_cache_line_size=8;;
     1|2|4|8|16|32|64|128|256|512|1024|2048|4096|8192)
	;;
     *)
	AC_MSG_ERROR([Invalid assumed cache-line size of $with_assumed_cache_line_size bytes])
	;;
esac

AC_DEFINE_UNQUOTED(ASSUMED_CACHE_LINE_SIZE,
		   $with_assumed_cache_line_size,
		   [Assumed cache-line size (in bytes)])

dnl Magic test for clearcase.
OTP_RELEASE=
if test "${ERLANG_COMMERCIAL_BUILD}" != ""; then
	OTP_EXTRA_FLAGS=-DOTP_RELEASE
	OTP_RELEASE=yes
else
	OTP_EXTRA_FLAGS=
fi
AC_SUBST(OTP_RELEASE)

AC_MSG_CHECKING([OTP release])
[SYSTEM_VSN=`cat $ERL_TOP/OTP_VERSION | sed "s|\([0-9]*\).*|\1|"`]
AC_MSG_RESULT([$SYSTEM_VSN])
AC_SUBST(SYSTEM_VSN)

AC_MSG_CHECKING([OTP version])
[OTP_VERSION=`cat $ERL_TOP/OTP_VERSION`]
AC_MSG_RESULT([$OTP_VERSION])
AC_SUBST(OTP_VERSION)

dnl ----------------------------------------------------------------------
dnl Canonicalise host string
dnl ----------------------------------------------------------------------
AC_CANONICAL_HOST
TARGET=$host
AC_SUBST(TARGET)

dnl ----------------------------------------------------------------------
dnl Checks for programs.
dnl ----------------------------------------------------------------------

AC_PROG_CC
AC_SUBST(GCC)

AC_CHECK_PROGS([OBJCOPY],
        ["$ac_tool_prefix"objcopy epiphany-unknown-elf-objcopy \
         epiphany-elf-objcopy e-objcopy objcopy],
        [none])
if test "X$OBJCOPY" = Xnone; then
        AC_MSG_ERROR([objcopy not found])
fi

AC_CHECK_PROGS([OBJDUMP],
        ["$ac_tool_prefix"objdump epiphany-unknown-elf-objdump \
         epiphany-elf-objdump e-objdump objdump],
        [none])
if test "X$OBJDUMP" = Xnone; then
        AC_MSG_ERROR([objdump not found])
fi

AC_PROG_SED
AC_PROG_EGREP

LM_PROG_PERL5
if test "$ac_cv_path_PERL" = false; then
  AC_MSG_ERROR([Perl version 5 is required to build the emulator!])
fi

dnl
dnl Flags to the C compiler
dnl
dnl Make sure we find config.h
dnl

extra_flags="-I${ERL_TOP}/erts/$host $OTP_EXTRA_FLAGS"
CFLAGS="$CFLAGS $extra_flags"
DEBUG_CFLAGS="-g $CPPFLAGS $extra_flags $DEBUG_CFLAGS"
DEBUG_FLAGS=-g


if test "x$GCC" = xyes; then
  # Treat certain GCC warnings as errors
  LM_TRY_ENABLE_CFLAG([-Werror=return-type], [WERRORFLAGS])

  # until the emulator can handle this, I suggest we turn it off!
  #WFLAGS="-Wall -Wshadow -Wcast-qual -Wmissing-declarations"
  WFLAGS="-Wall -Wstrict-prototypes -Wmissing-prototypes"

  saved_CFLAGS=$CFLAGS
  CFLAGS="$CFLAGS -Wdeclaration-after-statement"
  AC_TRY_COMPILE([],[;], warn_decl_after_st=true, warn_decl_after_st=false)
  if test "X$warn_decl_after_st" = "Xtrue"; then
    WFLAGS="$WFLAGS -Wdeclaration-after-statement"
  fi
  CFLAGS=$saved_CFLAGS
else
  WFLAGS=""
  WERRORFLAGS=""
fi
dnl DEBUG_FLAGS is obsolete (I hope)
AC_SUBST(DEBUG_FLAGS)
AC_SUBST(DEBUG_CFLAGS)
AC_SUBST(WFLAGS)
AC_SUBST(WERRORFLAGS)
AC_SUBST(CFLAG_RUNTIME_LIBRARY_PATH)

AC_CHECK_SIZEOF(void *) # Needed for ARCH and smp checks below
if test "x$ac_cv_sizeof_void_p" = x8; then
  AC_SUBST(EXTERNAL_WORD_SIZE, 64)
else
  AC_SUBST(EXTERNAL_WORD_SIZE, 32)
fi

dnl
dnl Figure out operating system and cpu architecture
dnl

OPSYS=noopsys

if test "x$host_alias" != "x" -a "x$host_cpu" != "x"; then
    chk_arch_=$host_cpu
else
    AC_MSG_ERROR([Could not decide the target architecture])
fi

case $chk_arch_ in
    epiphany)	ARCH=epiphany;;
    *)	 	ARCH=noarch;;
esac

AC_SUBST(OPSYS)
AC_SUBST(ARCH)

dnl some tests below will call this if we haven't already - and autoconf
dnl can't handle those tests being done conditionally at runtime
AC_PROG_CPP

_search_path=/bin:/usr/bin:/usr/local/bin:$PATH

AC_PATH_PROG(RM, rm, false, $_search_path)
if test "$ac_cv_path_RM" = false; then
  AC_MSG_ERROR([No 'rm' command found])
fi

_search_path=


dnl ----------------------------------------------------------------------
dnl Misc. things (some of them should go away)
dnl ----------------------------------------------------------------------

dnl We want to use $(CC) as linker for the emulator regardless of
dnl what the user say. This might not be the right way to do it, but
dnl for now that is the way we do it.
USER_LD=$LD
USER_LDFLAGS="$LDFLAGS"
LD='$(CC)'
AC_SUBST(LD)

LDFLAG_RUNTIME_LIBRARY_PATH="$CFLAG_RUNTIME_LIBRARY_PATH"
AC_SUBST(LDFLAG_RUNTIME_LIBRARY_PATH)

dnl Check for cygwin and object/exe files extension
dnl AC_CYGWIN is deprecated
AC_EXEEXT
AC_OBJEXT

dnl This is the os flavour, should be unix, ose, vxworks, epiphany or win32
ERLANG_OSTYPE=epiphany

AC_SUBST(ERLANG_OSTYPE)

dnl ----------------------------------------------------------------------
dnl Checks for libraries.
dnl ----------------------------------------------------------------------

AC_CHECK_LIB(m, sin)

AC_SEARCH_LIBS([e_mutex_lock], [e-lib])
if test "x$ac_cv_search_e_mutex_lock" = xno; then
   AC_MSG_ERROR([Could not find the Epiphany Hardware Utility Library (eLib)])
fi

dnl Try to find a thread library.
dnl
dnl We don't expect it to find anything, but we need the sizeof defines anyway
dnl to provide our own ethread implementation.
dnl
dnl ETHR_LIB_NAME, ETHR_LIBS, ETHR_X_LIBS, ETHR_THR_LIB_BASE and ETHR_DEFS
dnl are set by ERL_FIND_ETHR_LIB
ERL_FIND_ETHR_LIB

if test "X$ETHR_LIB_NAME" = "X"; then
    # We provide our own
    ETHR_DEFS="-DUSE_THREADS -DETHR_EPIPHANY $ETHR_DEFS"
    ETHR_THR_LIB_BASE_DIR=epiphany
fi

ERTS_BUILD_SMP_EMU=$enable_smp_support
AC_MSG_CHECKING(whether an emulator with smp support should be built)
case $ERTS_BUILD_SMP_EMU in
    yes)
	AC_MSG_RESULT(yes; enabled by user)
	;;
    no)
	AC_MSG_RESULT(no; disabled by user)
	;;
    unknown)
	AC_TRY_COMPILE([],[
			#if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
			;
			#else
			#error old or no gcc
			#endif
			],
			gcc_smp=okgcc,
			gcc_smp=oldornogcc)
	ERTS_BUILD_SMP_EMU=yes
	case "$enable_threads-$gcc_smp" in

	    no-*)
		AC_MSG_RESULT(no; threads disabled by user)
		ERTS_BUILD_SMP_EMU=no
		;;

	    *-okgcc)
		AC_MSG_RESULT(yes)
		ERTS_BUILD_SMP_EMU=yes
		;;

	    *-oldornogcc)
		AC_MSG_RESULT(no; old gcc or no gcc found)
		ERTS_BUILD_SMP_EMU=no
		;;

	    *)
		AC_MSG_RESULT(no)
		ERTS_BUILD_SMP_EMU=no
		;;
	esac
	;;
esac

if test $ERTS_BUILD_SMP_EMU = yes; then

	AC_DEFINE(ERTS_HAVE_SMP_EMU, 1, [Define if the smp emulator is built])

	enable_threads=force
fi

AC_SUBST(ERTS_BUILD_SMP_EMU)

#
# Figure out if the emulator should use threads. The default is set above
# in the enable_threads variable. It can have the following values:
#
#   no      single-threaded emulator requested
#   yes     multi-threaded emulator requested
#   force   multi-threaded emulator required
#
# EMU_THR_LIB_NAME, EMU_THR_LIBS, EMU_THR_X_LIBS, and EMU_THR_DEFS is
# used by the emulator, and can (but should not) be used by applications
# that only require thread support when the emulator has thread support.
# Other applications should use ETHR_LIB_NAME, ETHR_LIBS, ETHR_X_LIBS,
# and ETHR_DEFS.
#
AC_MSG_CHECKING(whether the emulator should use threads)

EMU_THR_LIB_NAME=
EMU_THR_X_LIBS=
EMU_THR_LIBS=
EMU_THR_DEFS=
emu_threads=no

case "$enable_threads" in
    force)
	emu_threads=yes
	AC_MSG_RESULT(yes; thread support required and therefore forced) ;;
    yes)
	emu_threads=yes
	AC_MSG_RESULT(yes; enabled by user) ;;
    unknown)
        emu_threads=yes
	AC_MSG_RESULT(yes; default on this platform) ;;
    no)
	AC_MSG_RESULT(no; thread support found but disabled by user) ;;
    *)
	AC_MSG_ERROR(internal error) ;;
esac

if test $emu_threads != yes; then
	enable_lock_check=no
	enable_lock_count=no
else
	# Threads enabled for emulator
	EMU_THR_LIB_NAME=$ETHR_LIB_NAME
	EMU_THR_X_LIBS=$ETHR_X_LIBS
	EMU_THR_LIBS=$ETHR_LIBS
	EMU_THR_DEFS=$ETHR_DEFS
	ENABLE_ALLOC_TYPE_VARS="$ENABLE_ALLOC_TYPE_VARS threads"
	AC_MSG_CHECKING(whether lock checking should be enabled)
	AC_MSG_RESULT($enable_lock_check)
	if test "x$enable_lock_check" != "xno"; then
	    EMU_THR_DEFS="$EMU_THR_DEFS -DERTS_ENABLE_LOCK_CHECK"
	fi

	AC_MSG_CHECKING(whether lock counters should be enabled)
	AC_MSG_RESULT($enable_lock_count)
	if test "x$enable_lock_count" != "xno"; then
	    EMU_THR_DEFS="$EMU_THR_DEFS -DERTS_ENABLE_LOCK_COUNT"
	fi
fi

AC_SUBST(EMU_THR_DEFS)

if test "x$enable_lock_check" = "xno"; then
    EMU_LOCK_CHECKING=no
else
    EMU_LOCK_CHECKING=yes
fi

AC_SUBST(EMU_LOCK_CHECKING)

ERL_INTERNAL_LIBS

dnl ----------------------------------------------------------------------
dnl Checks for header files.
dnl ----------------------------------------------------------------------

dnl We sometimes need EMU_THR_DEFS in order to find certain headers.
saved_cppflags=$CPPFLAGS
CPPFLAGS="$CPPFLAGS $EMU_THR_DEFS"

AC_HEADER_DIRENT
AC_HEADER_STDC
AC_HEADER_SYS_WAIT
AC_HEADER_TIME

AC_CHECK_HEADERS(limits.h unistd.h syslog.h ieeefp.h \
                 sys/types.h sys/stropts.h \
                 sys/time.h sys/uio.h malloc.h \
		 pty.h util.h utmp.h langinfo.h poll.h sdkddkver.h)

AC_CHECK_HEADER(sys/resource.h,
	[AC_DEFINE(HAVE_SYS_RESOURCE_H, 1,
		[Define to 1 if you have the <sys/resource.h> header file])
	 AC_CHECK_DECLS([getrlimit, setrlimit, RLIMIT_STACK],
		[],[],
		[#include <sys/resource.h>])],
	[],[])

HAVE_VALGRIND=no
AC_CHECK_HEADER(valgrind/valgrind.h, HAVE_VALGRIND=yes)
AC_SUBST(HAVE_VALGRIND)

LM_DECL_SYS_ERRLIST

dnl restore CPPFLAGS
CPPFLAGS=$saved_cppflags

dnl ----------------------------------------------------------------------
dnl Checks for typedefs, structures, and compiler characteristics.
dnl ----------------------------------------------------------------------

AC_C_CONST
AC_TYPE_SIGNAL
AC_TYPE_OFF_T
AC_TYPE_PID_T
AC_TYPE_SIZE_T

LM_STRUCT_EXCEPTION

AC_CHECK_SIZEOF(char, 1)
AC_CHECK_SIZEOF(short)
AC_CHECK_SIZEOF(int)
AC_CHECK_SIZEOF(long)
AC_CHECK_SIZEOF(void *)
AC_CHECK_SIZEOF(long long)
AC_CHECK_SIZEOF(size_t)
AC_CHECK_SIZEOF(off_t)
AC_CHECK_SIZEOF(time_t)

if test "x$ac_compiler_gnu" = "xyes"; then
AC_MSG_CHECKING([if we should add -fno-tree-copyrename to CFLAGS for computed gotos to work properly])
AC_TRY_COMPILE([],[
		#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
			;
			#else
			#error old and ok
			#endif
			],
			no_tree_copyrename=yes,
			no_tree_copyrename=no)

if test "x$no_tree_copyrename" = "xyes"; then
	CFLAGS="$CFLAGS -fno-tree-copyrename"
	AC_MSG_RESULT(yes, adjusting CFLAGS)
else
	AC_MSG_RESULT(no)
fi

fi

case X$erl_xcomp_bigendian in
    X) ;;
    Xyes|Xno) ac_cv_c_bigendian=$erl_xcomp_bigendian;;
    *) AC_MSG_ERROR([Bad erl_xcomp_bigendian value: $erl_xcomp_bigendian]);;
esac

AC_C_BIGENDIAN
AC_C_DOUBLE_MIDDLE_ENDIAN

dnl ----------------------------------------------------------------------
dnl Checks for library functions.
dnl ----------------------------------------------------------------------

dnl We may need the thread library and thread flags in order to find right stuff
saved_cppflags=$CPPFLAGS
CPPFLAGS="$CPPFLAGS $EMU_THR_DEFS"
saved_libs=$LIBS
LIBS="$LIBS $EMU_THR_X_LIBS"

AC_CHECK_FUNCS([ieee_handler fpsetmask finite isnan isinf \
		pread pwrite memmove strerror strerror_r strncasecmp \
		gethrtime localtime_r gmtime_r \
		memcpy mallopt sbrk _sbrk __sbrk brk _brk __brk \
		strlcpy strlcat posix2time time2posix])

AC_MSG_CHECKING([for isfinite])
AC_TRY_LINK([#include <math.h>],
            [isfinite(0);], have_isfinite=yes, have_isfinite=no),

if test $have_isfinite = yes; then
    AC_DEFINE(HAVE_ISFINITE,[1],
              [Define to 1 if you have the `isfinite' function.])
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

dnl ----------------------------------------------------------------------
dnl Checks for features/quirks in the system that affects Erlang.
dnl ----------------------------------------------------------------------

AC_CACHE_CHECK([for 'end' symbol],
		erts_cv_have_end_symbol,
		[AC_TRY_LINK([],
			[extern char end; {char *x = &end; *x= 0;}],
			erts_cv_have_end_symbol=yes,
			erts_cv_have_end_symbol=no)])
if test $erts_cv_have_end_symbol = yes; then
	AC_DEFINE(HAVE_END_SYMBOL, 1, [Define if you have the 'end' symbol])
fi

AC_CACHE_CHECK([for '_end' symbol],
		erts_cv_have__end_symbol,
		[AC_TRY_LINK([],
			[extern char _end; {char *x = &_end; *x= 0;}],
			erts_cv_have__end_symbol=yes,
			erts_cv_have__end_symbol=no)])
if test $erts_cv_have__end_symbol = yes; then
	AC_DEFINE(HAVE__END_SYMBOL, 1, [Define if you have the '_end' symbol])
fi

AC_CACHE_CHECK([if __after_morecore_hook can track malloc()s core memory use],
		erts_cv___after_morecore_hook_can_track_malloc,
		[AC_TRY_RUN([
#include <stdlib.h>
#ifdef HAVE_MALLOC_H
#  include <malloc.h>
#endif
#if defined(HAVE_END_SYMBOL)
extern char end;
#elif defined(HAVE__END_SYMBOL)
extern char _end;
#endif
#ifndef USE_THREADS
#undef ETHR_PTHREADS
#endif

#ifdef ETHR_PTHREADS
#  ifdef ETHR_HAVE_PTHREAD_H
#    include <pthread.h>
#  else
#    ifdef ETHR_HAVE_MIT_PTHREAD_H
#      include <pthread/mit/pthread.h>
#    endif
#  endif
#  define N_THR 5
#else
#  define N_THR 1
#endif

static char *heap_start = NULL;
static char *heap_end = NULL;

void update_heap_size(void)
{
    heap_end = (char *) sbrk(0);
}

void init_hook(void)
{
#if defined(HAVE_END_SYMBOL)
    heap_start = &end;
#elif defined(HAVE__END_SYMBOL)
    heap_start = &_end;
#else
    heap_start = sbrk(0);
#endif
    __after_morecore_hook = update_heap_size;
}

void (*__malloc_initialize_hook) (void) = init_hook;

static int
check_malloc(int size)
{
    char *p = (char *) malloc(size);
    if (!heap_start || !heap_end) return 0;
    if (!p) return 0;
    if (p < heap_start || heap_end <= p) return 0;
    if (p + size < heap_start || heap_end < p + size) return 0;
    return 1;
}

#ifdef ETHR_PTHREADS
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
#endif

static void *
do_tests(void *vresp)
{
    int i, ok = 0;
#ifdef ETHR_PTHREADS
    if (pthread_mutex_lock(&mutex) != 0)
	return NULL;
#endif

    for (i = 0; i < 10; i++)
	if (!check_malloc(1000))
	    goto failed;
    for (i = 0; i < 100; i++)
	if (!check_malloc(1))
	    goto failed;
    if (!check_malloc(1024*1024+1))
	goto failed;
    if (!check_malloc(10*1024*1024+1))
	goto failed;
    ok = 1;

 failed:
#ifdef ETHR_PTHREADS
    if (pthread_mutex_unlock(&mutex) != 0)
	return NULL;
#endif
    if (ok)
	*((int *) vresp) = 0;
    return NULL;
}


int main(void)
{
    int res[N_THR], i;
#ifdef ETHR_PTHREADS
    pthread_t tid[N_THR];
#endif

#if defined(HAVE_MALLOPT) && defined(M_MMAP_MAX)
    (void) mallopt(M_MMAP_MAX, 0);
#endif

    for (i = 0; i < N_THR; i++)
	res[i] = 1;
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_create(&tid[i], NULL, do_tests, &res[i]) != 0)
	    return 1;
#endif
    (void) do_tests(&res[0]);
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_join(tid[i], NULL) != 0)
	    return 1;
#endif
    for (i = 0; i < N_THR; i++)
	if (res[i])
	    return 1;
    return 0;
}
	],
	erts_cv___after_morecore_hook_can_track_malloc=yes,
	erts_cv___after_morecore_hook_can_track_malloc=no,
	[
	case X$erl_xcomp_after_morecore_hook in
	    X) erts_cv___after_morecore_hook_can_track_malloc=cross;;
	    Xyes|Xno) erts_cv___after_morecore_hook_can_track_malloc=$erl_xcomp_after_morecore_hook;;
	    *) AC_MSG_ERROR([Bad erl_xcomp_after_morecore_hook value: $erl_xcomp_after_morecore_hook]);;
	esac
	]
	)])

case $erts_cv___after_morecore_hook_can_track_malloc in
	yes) AC_DEFINE(ERTS___AFTER_MORECORE_HOOK_CAN_TRACK_MALLOC, 1, \
[Define if __after_morecore_hook can track malloc()s core memory use.]);;
	cross) AC_MSG_WARN([result no guessed because of cross compilation]);;
	*) ;;
esac

if test "x$ac_cv_func_sbrk" = "xyes"; then
    AC_CACHE_CHECK([types of sbrk()s return value and argument],
		    erts_cv_sbrk_ret_arg_types,
		    [

	erts_cv_sbrk_ret_arg_types=unknown
	ret_types="void *,char *"
	arg_types="intptr_t,ptrdiff_t,int,long"
	save_ifs="$IFS"; IFS=","
	for rtype in $ret_types; do
	    for atype in $arg_types; do
		IFS=$save_ifs
		AC_TRY_COMPILE([#include <sys/types.h>
				#include <unistd.h>],
				[$rtype sbrk($atype incr);],
				[erts_cv_sbrk_ret_arg_types="$rtype,$atype"])
		IFS=","
		if test "$erts_cv_sbrk_ret_arg_types" != "unknown"; then
		    break 2
		fi
	    done
	done
	IFS=$save_ifs])
    
    if test "$erts_cv_sbrk_ret_arg_types" != "unknown"; then
	save_ifs="$IFS"; IFS=","
	read ret_type arg_type <<EOF
$erts_cv_sbrk_ret_arg_types
EOF
	IFS=$save_ifs
	AC_DEFINE_UNQUOTED(SBRK_RET_TYPE, $ret_type, \
[Define the sbrk() return type.])
	AC_DEFINE_UNQUOTED(SBRK_ARG_TYPE, $arg_type, \
[Define the sbrk() argument type.])
    fi
fi

if test $ac_cv_func_brk = yes; then
    AC_CACHE_CHECK([types of brk()s return value and argument],
		    erts_cv_brk_ret_arg_types,
		    [

	erts_cv_brk_ret_arg_types=unknown
	ret_types="int,long,char *,void *"
	arg_types="void *,const void *,char *,const char *"
	save_ifs="$IFS"; IFS=","
	for rtype in $ret_types; do
	    for atype in $arg_types; do
		IFS=$save_ifs
		AC_TRY_COMPILE([#include <sys/types.h>
				#include <unistd.h>],
				[$rtype brk($atype endds);],
				[erts_cv_brk_ret_arg_types="$rtype,$atype"])
		IFS=","
		if test "$erts_cv_brk_ret_arg_types" != "unknown"; then
		    break 2
		fi
	    done
	done
	IFS=$save_ifs])
    
    if test "$erts_cv_brk_ret_arg_types" != "unknown"; then
	save_ifs="$IFS"; IFS=","
	read ret_type arg_type <<EOF
$erts_cv_brk_ret_arg_types
EOF
	IFS=$save_ifs
	AC_DEFINE_UNQUOTED(BRK_RET_TYPE, $ret_type, \
[Define the brk() return type.])
	AC_DEFINE_UNQUOTED(BRK_ARG_TYPE, $arg_type, \
[Define the brk() argument type.])
    fi

fi

if test $ac_cv_func_sbrk = yes; then

    AC_CACHE_CHECK([if sbrk()/brk() wrappers can track malloc()s core memory use],
		    erts_cv_brk_wrappers_can_track_malloc,
		    [AC_TRY_RUN([
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#ifdef HAVE_DLFCN_H
#  include <dlfcn.h>
#endif

/*
 * Our implementation requires that we have sbrk(), and 'end' or '_end'.
 */

#if !defined(HAVE_SBRK)
#  error no sbrk()
#endif
#if defined(HAVE_END_SYMBOL)
extern char end;
#elif defined(HAVE__END_SYMBOL)
extern char _end;
#else
#  error no 'end' nor '_end'
#endif

#ifndef USE_THREADS
#undef ETHR_PTHREADS
#endif

#ifdef ETHR_PTHREADS
#  ifdef ETHR_HAVE_PTHREAD_H
#    include <pthread.h>
#  else
#    ifdef ETHR_HAVE_MIT_PTHREAD_H
#      include <pthread/mit/pthread.h>
#    endif
#  endif
#  define N_THR 5
#else
#  define N_THR 1
#endif

#define SBRK_IMPL(RET_TYPE, SBRK, ARG_TYPE)				\
RET_TYPE SBRK (ARG_TYPE);						\
static RET_TYPE (*real_ ## SBRK)(ARG_TYPE) = NULL;			\
RET_TYPE								\
SBRK (ARG_TYPE arg)							\
{									\
    RET_TYPE res;							\
    if (!real_ ## SBRK) real_ ## SBRK = dlsym(RTLD_NEXT, #SBRK);	\
    res = (*real_ ## SBRK)(arg);					\
    if (res != (RET_TYPE) -1) heap_end = (char *) (*real_ ## SBRK)(0);	\
    return res;								\
}

#define BRK_IMPL(RET_TYPE, BRK, ARG_TYPE)				\
RET_TYPE BRK (ARG_TYPE);						\
static RET_TYPE (*real_ ## BRK)(ARG_TYPE) = NULL;			\
RET_TYPE								\
BRK (ARG_TYPE arg)							\
{									\
    RET_TYPE res;							\
    if (!real_ ## BRK) real_ ## BRK = dlsym(RTLD_NEXT, #BRK);		\
    res = (*real_ ## BRK)(arg);						\
    if (res != (RET_TYPE) -1) heap_end = (char *) arg;			\
    return res;								\
}

static char *heap_start = NULL;
static char *heap_end = NULL;

SBRK_IMPL(SBRK_RET_TYPE, sbrk, SBRK_ARG_TYPE)
#ifdef HAVE_BRK
   BRK_IMPL(BRK_RET_TYPE, brk, BRK_ARG_TYPE)
#endif

#ifdef HAVE__SBRK
   SBRK_IMPL(SBRK_RET_TYPE, _sbrk, SBRK_ARG_TYPE)
#endif
#ifdef HAVE__BRK
   BRK_IMPL(BRK_RET_TYPE, _brk, BRK_ARG_TYPE)
#endif

#ifdef HAVE___SBRK
   SBRK_IMPL(SBRK_RET_TYPE, __sbrk, SBRK_ARG_TYPE)
#endif
#ifdef HAVE___BRK
   BRK_IMPL(BRK_RET_TYPE, __brk, BRK_ARG_TYPE)
#endif

static int
check_malloc(int size)
{
    char *p = (char *) malloc(size);
    if (!heap_start || !heap_end) return 0;
    if (!p) return 0;
    if (p < heap_start || heap_end <= p) return 0;
    if (p + size < heap_start || heap_end < p + size) return 0;
    return 1;
}

#ifdef ETHR_PTHREADS
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
#endif

static void *
do_tests(void *vresp)
{
    int i, ok = 0;
#ifdef ETHR_PTHREADS
    if (pthread_mutex_lock(&mutex) != 0)
	return NULL;
#endif

    for (i = 0; i < 10; i++)
	if (!check_malloc(1000))
	    goto failed;
    for (i = 0; i < 100; i++)
	if (!check_malloc(1))
	    goto failed;
    if (!check_malloc(1024*1024+1))
	goto failed;
    if (!check_malloc(10*1024*1024+1))
	goto failed;
    ok = 1;

 failed:
#ifdef ETHR_PTHREADS
    if (pthread_mutex_unlock(&mutex) != 0)
	return NULL;
#endif
    if (ok)
	*((int *) vresp) = 0;
    return NULL;
}


int main(void)
{
    int res[N_THR], i;
#ifdef ETHR_PTHREADS
    pthread_t tid[N_THR];
#endif
#if defined(HAVE_END_SYMBOL)
    heap_start = &end;
#elif defined(HAVE__END_SYMBOL)
    heap_start = &_end;
#endif

#if defined(HAVE_MALLOPT) && defined(M_MMAP_MAX)
    (void) mallopt(M_MMAP_MAX, 0);
#endif

    for (i = 0; i < N_THR; i++)
	res[i] = 1;
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_create(&tid[i], NULL, do_tests, &res[i]) != 0)
	    return 1;
#endif
    (void) do_tests(&res[0]);
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_join(tid[i], NULL) != 0)
	    return 1;
#endif
    for (i = 0; i < N_THR; i++)
	if (res[i])
	    return 1;
    return 0;
}
	],
	    erts_cv_brk_wrappers_can_track_malloc=yes,
	    erts_cv_brk_wrappers_can_track_malloc=no,
	    [
	    case X$erl_xcomp_dlsym_brk_wrappers in
		X) erts_cv_brk_wrappers_can_track_malloc=cross;;
		Xyes|Xno) erts_cv_brk_wrappers_can_track_malloc=$erl_xcomp_dlsym_brk_wrappers;;
		*) AC_MSG_ERROR([Bad erl_xcomp_dlsym_brk_wrappers value: $erl_xcomp_dlsym_brk_wrappers]);;
	    esac
	    ])])
	case $erts_cv_brk_wrappers_can_track_malloc in
	    yes)
		AC_DEFINE(ERTS_BRK_WRAPPERS_CAN_TRACK_MALLOC, 1, \
[Define if sbrk()/brk() wrappers can track malloc()s core memory use]);;
	    cross)
		AC_MSG_WARN([result no guessed because of cross compilation]);;
	    *) ;;
	esac
fi

dnl Restore LIBS
LIBS=$saved_libs
dnl restore CPPFLAGS
CPPFLAGS=$saved_cppflags

ERL_TIME_CORRECTION
AC_CHECK_PROG(M4, m4, m4)
dnl check to auto-enable hipe here...
if test "$cross_compiling" != "yes" && test X${enable_hipe} != Xno; then
  if test -z "$M4"; then
	enable_hipe=no
   	AC_MSG_NOTICE([HiPE disabled as no valid m4 is found in PATH])
  elif test "$enable_halfword_emulator" = "yes"; then
       if test X${enable_hipe} = Xyes; then
              AC_MSG_ERROR([HiPE can not be combined with halfword emulator (yet)])
       else		    
   	      AC_MSG_NOTICE([HiPE auto-disabled on halfword emulator])
       fi	
  else
  	case "$ARCH-$OPSYS" in
	    x86-linux|amd64-linux|x86-darwin*|amd64-darwin*|ppc-linux|ppc64-linux|ppc-darwin|arm-linux|amd64-freebsd|x86-freebsd|x86-sol2|amd64-sol2|ultrasparc-linux)
      		enable_hipe=yes
      		;;	
  	esac
  fi
fi

if test X${enable_fp_exceptions} = Xauto ; then
   case $host_os in
   	*linux*)
	      enable_fp_exceptions=no
	      AC_MSG_NOTICE([Floating point exceptions disabled by default on Linux]) ;;
	darwin*)
	      enable_fp_exceptions=no
	      AC_MSG_NOTICE([Floating point exceptions disabled by default on MacOS X]) ;;
	      *)
	      ;;
    esac
fi

if test X${enable_fp_exceptions} = Xauto ; then
   if test X${enable_hipe} = Xyes; then
      enable_fp_exceptions=yes
   else
      enable_fp_exceptions=no
   AC_MSG_NOTICE([Floating point exceptions disabled by default in this configuration])
   fi
fi	 

if test X${enable_fp_exceptions} != Xyes ; then
    AC_DEFINE(NO_FPE_SIGNALS,[],[Define if floating points exceptions are non-existing/not reliable])
    FPE=unreliable
else

    AC_MSG_CHECKING([for unreliable floating point execptions])


    AC_TRY_RUN([
/* fpe-test.c */
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

volatile int erl_fp_exception;

/*
 * We expect a single SIGFPE in this test program.
 * Getting many more indicates an inadequate SIGFPE handler,
 * e.g. using the generic handler on x86.
 */
static void new_fp_exception(void)
{
    if (++erl_fp_exception > 50) {
	fprintf(stderr, "SIGFPE loop detected, bailing out\n");
	exit(1);
    }
}

/* Is there no standard identifier for Darwin/MacOSX ? */
#if defined(__APPLE__) && defined(__MACH__) && !defined(__DARWIN__)
#define __DARWIN__ 1
#endif

/*
 * Implement unmask_fpe() and check_fpe() based on CPU/OS combination
 */

#if (defined(__i386__) || defined(__x86_64__)) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)

static void unmask_x87(void)
{
    unsigned short cw;
    __asm__ __volatile__("fstcw %0" : "=m"(cw));
    cw &= ~(0x01|0x04|0x08);   /* unmask IM, ZM, OM */
    __asm__ __volatile__("fldcw %0" : : "m"(cw));
}

static void unmask_sse2(void)
{
    unsigned int mxcsr;
    __asm__ __volatile__("stmxcsr %0" : "=m"(mxcsr));
    mxcsr &= ~(0x003F|0x0680); /* clear exn flags, unmask OM, ZM, IM (not PM, UM, DM) */
    __asm__ __volatile__("ldmxcsr %0" : : "m"(mxcsr));
}

#if defined(__x86_64__)

static inline int cpu_has_sse2(void) { return 1; }

#else /* !__x86_64__ */

/*
 * Check if an x86-32 processor has SSE2.
 */
static unsigned int xor_eflags(unsigned int mask)
{
    unsigned int eax, edx;

    eax = mask;			/* eax = mask */
    __asm__("pushfl\n\t"
	    "popl %0\n\t"	/* edx = original EFLAGS */
	    "xorl %0, %1\n\t"	/* eax = mask ^ EFLAGS */
	    "pushl %1\n\t"
	    "popfl\n\t"		/* new EFLAGS = mask ^ original EFLAGS */
	    "pushfl\n\t"
	    "popl %1\n\t"	/* eax = new EFLAGS */
	    "xorl %0, %1\n\t"	/* eax = new EFLAGS ^ old EFLAGS */
	    "pushl %0\n\t"
	    "popfl"		/* restore original EFLAGS */
	    : "=d"(edx), "=a"(eax)
	    : "1"(eax));
    return eax;
}

static __inline__ unsigned int cpuid_eax(unsigned int op)
{
    unsigned int eax, save_ebx;

    /* In PIC mode i386 reserves EBX. So we must save
       and restore it ourselves to not upset gcc. */
    __asm__(
	"movl %%ebx, %1\n\t"
	"cpuid\n\t"
	"movl %1, %%ebx"
	: "=a"(eax), "=m"(save_ebx)
	: "0"(op)
	: "cx", "dx");
    return eax;
}

static __inline__ unsigned int cpuid_edx(unsigned int op)
{
    unsigned int eax, edx, save_ebx;
 
    /* In PIC mode i386 reserves EBX. So we must save
       and restore it ourselves to not upset gcc. */
    __asm__(
	"movl %%ebx, %2\n\t"
	"cpuid\n\t"
	"movl %2, %%ebx"
	: "=a"(eax), "=d"(edx), "=m"(save_ebx)
	: "0"(op)
	: "cx");
    return edx;
}

/* The AC bit, bit #18, is a new bit introduced in the EFLAGS
 * register on the Intel486 processor to generate alignment
 * faults. This bit cannot be set on the Intel386 processor.
 */
static __inline__ int is_386(void)
{
    return ((xor_eflags(1<<18) >> 18) & 1) == 0;
}

/* Newer x86 processors have a CPUID instruction, as indicated by
 * the ID bit (#21) in EFLAGS being modifiable.
 */
static __inline__ int has_CPUID(void)
{
    return (xor_eflags(1<<21) >> 21) & 1;
}

static int cpu_has_sse2(void)
{
    unsigned int maxlev, features;
    static int has_sse2 = -1;

    if (has_sse2 >= 0)
	return has_sse2;
    has_sse2 = 0;

    if (is_386())
	return 0;
    if (!has_CPUID())
	return 0;
    maxlev = cpuid_eax(0);
    /* Intel A-step Pentium had a preliminary version of CPUID.
       It also didn't have SSE2. */
    if ((maxlev & 0xFFFFFF00) == 0x0500)
	return 0;
    /* If max level is zero then CPUID cannot report any features. */
    if (maxlev == 0)
	return 0;
    features = cpuid_edx(1);
    has_sse2 = (features & (1 << 26)) != 0;

    return has_sse2;
}
#endif /* !__x86_64__ */

static void unmask_fpe(void)
{
    unmask_x87();
    if (cpu_has_sse2())
	unmask_sse2();
}

static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("fwait" : "=m"(erl_fp_exception) : "m"(f));
    if (!erl_fp_exception)
       return 0;
    __asm__ __volatile__("fninit");
    unmask_fpe();
    return 1;
}

#elif defined(__sparc__) && defined(__linux__)

#if defined(__arch64__)
#define LDX "ldx"
#define STX "stx"
#else
#define LDX "ld"
#define STX "st"
#endif

static void unmask_fpe(void)
{
    unsigned long fsr;

    __asm__(STX " %%fsr, %0" : "=m"(fsr));
    fsr &= ~(0x1FUL << 23);	/* clear FSR[TEM] field */
    fsr |= (0x1AUL << 23);	/* enable NV, OF, DZ exceptions */
    __asm__ __volatile__(LDX " %0, %%fsr" : : "m"(fsr));
}

static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("" : "=m"(erl_fp_exception) : "em"(f));
    return erl_fp_exception;
}

#elif (defined(__powerpc__) && defined(__linux__)) || (defined(__ppc__) && defined(__DARWIN__))

#if defined(__linux__)

#include <sys/prctl.h>

static void set_fpexc_precise(void)
{
    if (prctl(PR_SET_FPEXC, PR_FP_EXC_PRECISE) < 0) {
	perror("PR_SET_FPEXC");
	exit(1);
    }
}

#elif defined(__DARWIN__)

#include <mach/mach.h>
#include <pthread.h>

/*
 * FE0 FE1	MSR bits
 *  0   0	floating-point exceptions disabled
 *  0   1	floating-point imprecise nonrecoverable
 *  1   0	floating-point imprecise recoverable
 *  1   1	floating-point precise mode
 *
 * Apparently:
 * - Darwin 5.5 (MacOS X <= 10.1) starts with FE0 == FE1 == 0,
 *   and resets FE0 and FE1 to 0 after each SIGFPE.
 * - Darwin 6.0 (MacOS X 10.2) starts with FE0 == FE1 == 1,
 *   and does not reset FE0 or FE1 after a SIGFPE.
 */
#define FE0_MASK	(1<<11)
#define FE1_MASK	(1<<8)

/* a thread cannot get or set its own MSR bits */
static void *fpu_fpe_enable(void *arg)
{
    thread_t t = *(thread_t*)arg;
    struct ppc_thread_state state;
    unsigned int state_size = PPC_THREAD_STATE_COUNT;

    if (thread_get_state(t, PPC_THREAD_STATE, (natural_t*)&state, &state_size) != KERN_SUCCESS) {
	perror("thread_get_state");
	exit(1);
    }
    if ((state.srr1 & (FE1_MASK|FE0_MASK)) != (FE1_MASK|FE0_MASK)) {
#if 0
	/* This would also have to be performed in the SIGFPE handler
	   to work around the MSR reset older Darwin releases do. */
	state.srr1 |= (FE1_MASK|FE0_MASK);
	thread_set_state(t, PPC_THREAD_STATE, (natural_t*)&state, state_size);
#else
	fprintf(stderr, "srr1 == 0x%08x, your Darwin is too old\n", state.srr1);
	exit(1);
#endif
    }
    return NULL; /* Ok, we appear to be on Darwin 6.0 or later */
}

static void set_fpexc_precise(void)
{
    thread_t self = mach_thread_self();
    pthread_t enabler;

    if (pthread_create(&enabler, NULL, fpu_fpe_enable, &self)) {
	perror("pthread_create");
    } else if (pthread_join(enabler, NULL)) {
	perror("pthread_join");
    }
}

#endif

static void set_fpscr(unsigned int fpscr)
{
    union {
	double d;
	unsigned int fpscr[2];
    } u;
    u.fpscr[0] = 0xFFF80000;
    u.fpscr[1] = fpscr;
    __asm__ __volatile__("mtfsf 255,%0" : : "f"(u.d));
}

static void unmask_fpe(void)
{
    set_fpexc_precise();
    set_fpscr(0x80|0x40|0x10);	/* VE, OE, ZE; not UE or XE */
}

static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("" : "=m"(erl_fp_exception) : "fm"(f));
    return erl_fp_exception;
}

#else

#include <ieeefp.h>

#define unmask_fpe()   fpsetmask(FP_X_INV | FP_X_OFL | FP_X_DZ)

static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("" : "=m"(erl_fp_exception) : "g"(f));
    return erl_fp_exception;
}

#endif

/*
 * Implement SIGFPE handler based on CPU/OS combination
 */

#if (defined(__linux__) && (defined(__i386__) || defined(__x86_64__) || defined(__sparc__) || defined(__powerpc__))) || (defined(__DARWIN__) && (defined(__i386__) || defined(__x86_64__) || defined(__ppc__))) || (defined(__FreeBSD__) && (defined(__i386__) || defined(__x86_64__))) || ((defined(__OpenBSD__) || defined(__NetBSD__)) && defined(__x86_64__)) || (defined(__sun__) && defined(__x86_64__))

#if defined(__linux__) && defined(__i386__)
#if !defined(X86_FXSR_MAGIC)
#define X86_FXSR_MAGIC 0x0000
#endif
#elif defined(__FreeBSD__) && defined(__i386__)
#include <sys/types.h>
#include <machine/npx.h>
#elif defined(__FreeBSD__) && defined(__x86_64__)
#include <sys/types.h>
#include <machine/fpu.h>
#elif defined(__DARWIN__)
#include <machine/signal.h>
#elif defined(__OpenBSD__) && defined(__x86_64__)
#include <sys/types.h>
#include <machine/fpu.h>
#endif
#if !(defined(__OpenBSD__) && defined(__x86_64__))
#include <ucontext.h>
#endif
#include <string.h>

static void fpe_sig_action(int sig, siginfo_t *si, void *puc)
{
    ucontext_t *uc = puc;
#if defined(__linux__)
#if defined(__x86_64__)
    mcontext_t *mc = &uc->uc_mcontext;
    fpregset_t fpstate = mc->fpregs;
    fpstate->mxcsr = 0x1F80;
    fpstate->swd &= ~0xFF;
#elif defined(__i386__)
    mcontext_t *mc = &uc->uc_mcontext;
    fpregset_t fpstate = mc->fpregs;
    if ((fpstate->status >> 16) == X86_FXSR_MAGIC)
	((struct _fpstate*)fpstate)->mxcsr = 0x1F80;
    fpstate->sw &= ~0xFF;
#elif defined(__sparc__) && defined(__arch64__)
    /* on SPARC the 3rd parameter points to a sigcontext not a ucontext */
    struct sigcontext *sc = (struct sigcontext*)puc;
    sc->sigc_regs.tpc = sc->sigc_regs.tnpc;
    sc->sigc_regs.tnpc += 4;
#elif defined(__sparc__)
    /* on SPARC the 3rd parameter points to a sigcontext not a ucontext */
    struct sigcontext *sc = (struct sigcontext*)puc;
    sc->si_regs.pc = sc->si_regs.npc;
    sc->si_regs.npc = (unsigned long)sc->si_regs.npc + 4;
#elif defined(__powerpc__)
#if defined(__powerpc64__)
    mcontext_t *mc = &uc->uc_mcontext;
    unsigned long *regs = &mc->gp_regs[0];
#else
    mcontext_t *mc = uc->uc_mcontext.uc_regs;
    unsigned long *regs = &mc->gregs[0];
#endif
    regs[PT_NIP] += 4;
    regs[PT_FPSCR] = 0x80|0x40|0x10;	/* VE, OE, ZE; not UE or XE */
#endif
#elif defined(__DARWIN__)
#if defined(DARWIN_MODERN_MCONTEXT)
#if defined(__x86_64__)
    mcontext_t mc = uc->uc_mcontext;
    struct __darwin_x86_float_state64 *fpstate = &mc->__fs;
    fpstate->__fpu_mxcsr = 0x1F80;
    *(unsigned short *)&fpstate->__fpu_fsw &= ~0xFF;
#elif defined(__i386__)
    mcontext_t mc = uc->uc_mcontext;
    struct __darwin_i386_float_state *fpstate = &mc->__fs;
    fpstate->__fpu_mxcsr = 0x1F80;
    *(unsigned short *)&fpstate->__fpu_fsw &= ~0xFF;
#elif defined(__ppc__)
    mcontext_t mc = uc->uc_mcontext;
    mc->ss.srr0 += 4;
    mc->fs.fpscr = 0x80|0x40|0x10;
#endif
#else
#if defined(__x86_64__)
    mcontext_t mc = uc->uc_mcontext;
    struct x86_float_state64_t *fpstate = &mc->fs;
    fpstate->fpu_mxcsr = 0x1F80;
    *(unsigned short *)&fpstate->fpu_fsw &= ~0xFF;
#elif defined(__i386__)
    mcontext_t mc = uc->uc_mcontext;
    x86_float_state32_t	*fpstate = &mc->fs;
    fpstate->fpu_mxcsr = 0x1F80;
    *(unsigned short *)&fpstate->fpu_fsw &= ~0xFF;
#elif defined(__ppc__)
    mcontext_t mc = uc->uc_mcontext;
    mc->ss.srr0 += 4;
    mc->fs.fpscr = 0x80|0x40|0x10;
#endif
#endif
#elif defined(__FreeBSD__) && defined(__x86_64__)
    mcontext_t *mc = &uc->uc_mcontext;
    struct savefpu *savefpu = (struct savefpu*)&mc->mc_fpstate;
    struct envxmm *envxmm = &savefpu->sv_env;
    envxmm->en_mxcsr = 0x1F80;
    envxmm->en_sw &= ~0xFF;
#elif defined(__FreeBSD__) && defined(__i386__)
    mcontext_t *mc = &uc->uc_mcontext;
    union savefpu *savefpu = (union savefpu*)&mc->mc_fpstate;
    if (mc->mc_fpformat == _MC_FPFMT_XMM) {
	struct envxmm *envxmm = &savefpu->sv_xmm.sv_env;
	envxmm->en_mxcsr = 0x1F80;
	envxmm->en_sw &= ~0xFF;
    } else {
	struct env87 *env87 = &savefpu->sv_87.sv_env;
	env87->en_sw &= ~0xFF;
    }
#elif defined(__OpenBSD__) && defined(__x86_64__)
    struct fxsave64 *fxsave = uc->sc_fpstate;
    fxsave->fx_mxcsr = 0x1F80;
    fxsave->fx_fsw &= ~0xFF;
#elif defined(__NetBSD__) && defined(__x86_64__)
    mcontext_t *mc = &uc->uc_mcontext;
    struct fxsave64 *fxsave = (struct fxsave64 *)&mc->__fpregs;
    fxsave->fx_mxcsr = 0x1F80;
    fxsave->fx_fsw &= ~0xFF;
#elif defined(__sun__) && defined(__x86_64__)
    mcontext_t *mc = &uc->uc_mcontext;
    struct fpchip_state *fpstate = &mc->fpregs.fp_reg_set.fpchip_state;
    fpstate->mxcsr = 0x1F80;
    fpstate->sw &= ~0xFF;
#endif
    new_fp_exception();
}

static void catch_sigfpe(void)
{
    struct sigaction act;

    memset(&act, 0, sizeof act);
    act.sa_sigaction = fpe_sig_action;
    act.sa_flags = SA_SIGINFO;
    sigaction(SIGFPE, &act, NULL);
}

#else

static void fpe_sig_handler(int sig)
{
    new_fp_exception();
}

static void catch_sigfpe(void)
{
    signal(SIGFPE, fpe_sig_handler);
}

#endif

/*
 * Generic test code
 */

static void do_init(void)
{
    catch_sigfpe();
    unmask_fpe();
}

double a = 3.23e133;
double b = 3.57e257;
double res;

void do_fmul(void)
{
    res = a * b;
}

int do_check(void)
{
    if (check_fpe(res)) {
       fprintf(stderr, "res = %g, FPE worked\n", res);
       return 0;
    } else {
       fprintf(stderr, "res = %g, FPE failed\n", res);
       return 1;
    }
}

int main(int argc, const char **argv)
{
    if (argc == 3) {
       a = atof(argv[1]);
       b = atof(argv[2]);
    }
    do_init();
    do_fmul();
    return do_check();
}
],
erl_ok=yes,
erl_ok=no,
[
case X$erl_xcomp_reliable_fpe in
    X) erl_ok=cross;;
    Xyes|Xno) erl_ok=$erl_xcomp_reliable_fpe;;
    *) AC_MSG_ERROR([Bad erl_xcomp_reliable_fpe value: $erl_xcomp_reliable_fpe]);;
esac
])

    if test $erl_ok = yes; then
	FPE=reliable
        AC_MSG_RESULT(reliable)
    else
	FPE=unreliable
	AC_MSG_RESULT([unreliable; testing in software instead])
	AC_DEFINE(NO_FPE_SIGNALS,[],[Define if floating points exceptions are non-existing/not reliable])
	if test $erl_ok = cross; then
	    AC_MSG_WARN([result unreliable guessed because of cross compilation])
	fi
    fi
fi

AC_MSG_CHECKING([whether putenv() stores a copy of the key-value pair])
AC_TRY_RUN([
#include <stdlib.h>
int main(void) {
    int i;
    char *env;
    char buf[10];
    for (i = 0; i < 7; i++)
	buf[i] = 'X';
    buf[i] = '\0';
    buf[3] = '=';
    if (putenv(buf) != 0)
	return 1;
    for (i = 4; i < 7; i++)
	buf[i] = 'Y';
    env = getenv("XXX");
    if (!env)
	return 2;
    for (i = 0; i < 3; i++)
	if (env[i] != 'X')
	    return 3;
    for (i = 0; i < 3; i++)
	buf[i] = 'Y';
    env = getenv("XXX");
    if (!env)
	return 4;
    for (i = 0; i < 3; i++)
	if (env[i] != 'X')
	    return 5;
    return 0;
}
],
copying_putenv=yes,
copying_putenv=no,
[
case X$erl_xcomp_putenv_copy in
    X) copying_putenv=cross;;
    Xyes|Xno) copying_putenv=$erl_xcomp_putenv_copy;;
    *) AC_MSG_ERROR([Bad erl_xcomp_putenv_copy value: $erl_xcomp_putenv_copy]);;
esac
])

AC_MSG_RESULT($copying_putenv)
case $copying_putenv in
    yes)
	AC_DEFINE(HAVE_COPYING_PUTENV,[1],\
[Define if you have a putenv() that stores a copy of the key-value pair]);;
    cross)
	AC_MSG_WARN([result no guessed because of cross compilation]);;
    *) ;;
esac

AC_SUBST(STATIC_CFLAGS)

dnl
dnl We should look for a compiler that handles jump tables, for beam_emu 
dnl to be optimized
dnl

LM_FIND_EMU_CC

dnl
dnl ERTS_EMU_CMDLINE_FLAGS will force modification of config.h when
dnl the emulator command line flags are modified by configure, which
dnl in turn will make 'make' detect that files depending on config.h
dnl needs to be rebuilt.
dnl

AC_DEFINE_UNQUOTED(ERTS_EMU_CMDLINE_FLAGS,
"$STATIC_CFLAGS $CFLAGS $DEBUG_CFLAGS $EMU_THR_DEFS $DEFS $WERRORFLAGS $WFLAGS",
[The only reason ERTS_EMU_CMDLINE_FLAGS exists is to force modification of config.h when the emulator command line flags are modified by configure])

dnl ---------------------------------------------------------------------
dnl Autoheader macro for adding code at top and bottom of config.h.in
dnl ---------------------------------------------------------------------
AH_TOP([
#define GHBN_R_SOLARIS  2
#define GHBN_R_AIX      3
#define GHBN_R_GLIBC    4
])

AH_BOTTOM([
/* Redefine in6_addr. XXX this should be moved to the files where it's used? */
#ifdef HAVE_IN_ADDR6_STRUCT
#define in6_addr in_addr6
#endif

/* Define a reasonable default for INADDR_LOOPBACK */
/* XXX this should be moved to the files where it's used? */
#ifdef HAVE_NO_INADDR_LOOPBACK
#define INADDR_LOOPBACK (u_long)0x7F000001
#endif

#ifdef REDEFINE_FD_SETSIZE
#define FD_SETSIZE 1024
#endif
 
#ifdef HAVE_GETHRVTIME_PROCFS_IOCTL
#define HAVE_GETHRVTIME
#endif

#if !defined(HAVE_ISFINITE) && !defined(HAVE_FINITE)
# if defined(HAVE_ISINF) && defined(HAVE_ISNAN)
#  define USE_ISINF_ISNAN
# endif
#endif

/* Lock checking does not currently work with the slave emulator. */
#if defined(ERTS_ENABLE_LOCK_CHECK)
#undef ERTS_ENABLE_LOCK_CHECK
#endif
])

if test "x$GCC" = xyes; then
  CFLAGS="$WERRORFLAGS $CFLAGS"
fi

dnl ----------------------------------------------------------------------
dnl Enable -fsanitize= flags.
dnl ----------------------------------------------------------------------

m4_define(DEFAULT_SANITIZERS, [address,undefined])
AC_ARG_ENABLE(
    sanitizers,
    AS_HELP_STRING(
        [--enable-sanitizers@<:@=comma-separated list of sanitizers@:>@],
	    [Default=DEFAULT_SANITIZERS]),
[
case "$enableval" in
    no) sanitizers= ;;
    yes) sanitizers="-fsanitize=DEFAULT_SANITIZERS" ;;
    *) sanitizers="-fsanitize=$enableval" ;;
esac
CFLAGS="$CFLAGS $sanitizers"
LDFLAGS="$LDFLAGS $sanitizers"
])

dnl ----------------------------------------------------------------------
dnl Output the result.
dnl ----------------------------------------------------------------------

dnl  Note that the output files are relative to $srcdir

AC_OUTPUT(
  Makefile
  info.mk
  )
